/*
 * Commspace API
 *   # Authentication In order to use this API you'll need two things to authenticate: - an **account_id** which identifies which Commspace account (tenant) you're integrating into. This is provided in the url of all api methods `/accounts/{account_id}/...` - an **API Key** which authenticates your access to the account. This is provided as a header as described below  # Mapping master data  Commspace relies on master data (clients, products, intermediaries) supplied by consumer systems in order to do revenue management. We've chosen to implement a consumer-supplied key system to minimize the data mapping burden for consumers. This means that for all master data entities, the consumer supplies their own unique identifier for each entity. Commspace will store that identifier internally and link any subsequent requests with the same identifier to that same entity. In the [specification](/spec.html) you can easily spot these identifier fields as all fields named with the pattern `<entity>_id` e.g. `client_id`, `product_id`, `intermediary_id`, etc.  Some key mappings (providers, product categories, commission types) have to be pre-configured by the Commspace team ahead of time. We will take responsibility for creating the necessary mappings of your identifiers for each of these entities to their Commspace equivalents - all we require is a full list of the values that you will send.  # Generating-Reports Reports can be generated through the methods exposed at the reports root.  Because reports can take a long time to generate this API does not support blocking calls i.e. wait until the report is generated before returning a response.  This API supports two patterns for non-blocking / asynchronous generation of reports:  - **Callback pattern**. The consumer provides a callback URL to post the report to. This is the preferred pattern.  - **Polling pattern**. The consumer repeatedly polls an endpoint to retrieve the report.  ## Callback pattern To make use of this pattern, simply specify a callback_url in the request to `/accounts/{account_id}/reports`.  When the report has been generated, Commspace will submit a POST to the provided URL with the following:  - report-token is the report token returned by the createReport call  - filename contains a suggested filename.  - content is a base64 encoded string of the binary data of the report  ## Polling pattern When a report is successfully requested, the API responds with a report_token in the response. Consumers can use this token to poll the endpoint `/accounts/{account_id}/reports/{report_token}`.  If the report isn't available yet, a 202 response will be returned. If the report is available a 200 response including the report will be returned. 
 *
 * OpenAPI spec version: 1.1.2
 * Contact: api@commspace.co.za
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package za.co.commspace.api.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.v3.oas.annotations.media.Schema;
import java.time.LocalDate;
import za.co.commspace.api.model.TransactionClientDetails;
import za.co.commspace.api.model.TransactionIntermediaryDetails;
import za.co.commspace.api.model.TransactionProductDetails;
/**
 * Represents a single revenue transaction.
 */
@Schema(description = "Represents a single revenue transaction.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2021-09-15T08:32:32.372Z[GMT]")
public class Transaction {
  @JsonProperty("transaction_id")
  private String transactionId = null;

  @JsonProperty("transaction_date")
  private LocalDate transactionDate = null;

  @JsonProperty("product_details")
  private TransactionProductDetails productDetails = null;

  @JsonProperty("client_details")
  private TransactionClientDetails clientDetails = null;

  @JsonProperty("intermediary_details")
  private TransactionIntermediaryDetails intermediaryDetails = null;

  @JsonProperty("transaction_type_id")
  private String transactionTypeId = null;

  @JsonProperty("premium")
  private Double premium = null;

  @JsonProperty("amount_ex_vat")
  private Double amountExVat = null;

  @JsonProperty("vat")
  private Double vat = null;

  @JsonProperty("amount")
  private Double amount = null;

  @JsonProperty("vat_exempt")
  private Boolean vatExempt = null;

  @JsonProperty("currency")
  private String currency = null;

  @JsonProperty("currency_exchange_rate")
  private Double currencyExchangeRate = null;

  public Transaction transactionId(String transactionId) {
    this.transactionId = transactionId;
    return this;
  }

   /**
   * unique identifier by which this transaction is known at consumer
   * @return transactionId
  **/
  @Schema(example = "12442453", required = true, description = "unique identifier by which this transaction is known at consumer")
  public String getTransactionId() {
    return transactionId;
  }

  public void setTransactionId(String transactionId) {
    this.transactionId = transactionId;
  }

  public Transaction transactionDate(LocalDate transactionDate) {
    this.transactionDate = transactionDate;
    return this;
  }

   /**
   * date of transaction in format defined by RFC3339.
   * @return transactionDate
  **/
  @Schema(required = true, description = "date of transaction in format defined by RFC3339.")
  public LocalDate getTransactionDate() {
    return transactionDate;
  }

  public void setTransactionDate(LocalDate transactionDate) {
    this.transactionDate = transactionDate;
  }

  public Transaction productDetails(TransactionProductDetails productDetails) {
    this.productDetails = productDetails;
    return this;
  }

   /**
   * Get productDetails
   * @return productDetails
  **/
  @Schema(description = "")
  public TransactionProductDetails getProductDetails() {
    return productDetails;
  }

  public void setProductDetails(TransactionProductDetails productDetails) {
    this.productDetails = productDetails;
  }

  public Transaction clientDetails(TransactionClientDetails clientDetails) {
    this.clientDetails = clientDetails;
    return this;
  }

   /**
   * Get clientDetails
   * @return clientDetails
  **/
  @Schema(description = "")
  public TransactionClientDetails getClientDetails() {
    return clientDetails;
  }

  public void setClientDetails(TransactionClientDetails clientDetails) {
    this.clientDetails = clientDetails;
  }

  public Transaction intermediaryDetails(TransactionIntermediaryDetails intermediaryDetails) {
    this.intermediaryDetails = intermediaryDetails;
    return this;
  }

   /**
   * Get intermediaryDetails
   * @return intermediaryDetails
  **/
  @Schema(description = "")
  public TransactionIntermediaryDetails getIntermediaryDetails() {
    return intermediaryDetails;
  }

  public void setIntermediaryDetails(TransactionIntermediaryDetails intermediaryDetails) {
    this.intermediaryDetails = intermediaryDetails;
  }

  public Transaction transactionTypeId(String transactionTypeId) {
    this.transactionTypeId = transactionTypeId;
    return this;
  }

   /**
   * text representation of the transaction type as it is known at the consumer
   * @return transactionTypeId
  **/
  @Schema(example = "initial", required = true, description = "text representation of the transaction type as it is known at the consumer")
  public String getTransactionTypeId() {
    return transactionTypeId;
  }

  public void setTransactionTypeId(String transactionTypeId) {
    this.transactionTypeId = transactionTypeId;
  }

  public Transaction premium(Double premium) {
    this.premium = premium;
    return this;
  }

   /**
   * the client contribution that the provider received
   * @return premium
  **/
  @Schema(example = "100", description = "the client contribution that the provider received")
  public Double getPremium() {
    return premium;
  }

  public void setPremium(Double premium) {
    this.premium = premium;
  }

  public Transaction amountExVat(Double amountExVat) {
    this.amountExVat = amountExVat;
    return this;
  }

   /**
   * The amount ex VAT (commission and fees) received from the provider
   * @return amountExVat
  **/
  @Schema(example = "500", required = true, description = "The amount ex VAT (commission and fees) received from the provider")
  public Double getAmountExVat() {
    return amountExVat;
  }

  public void setAmountExVat(Double amountExVat) {
    this.amountExVat = amountExVat;
  }

  public Transaction vat(Double vat) {
    this.vat = vat;
    return this;
  }

   /**
   * The VAT portion (if any) of the total amount received from the provider
   * @return vat
  **/
  @Schema(example = "75", description = "The VAT portion (if any) of the total amount received from the provider")
  public Double getVat() {
    return vat;
  }

  public void setVat(Double vat) {
    this.vat = vat;
  }

  public Transaction amount(Double amount) {
    this.amount = amount;
    return this;
  }

   /**
   * The total amount received from the provider
   * @return amount
  **/
  @Schema(example = "575", required = true, description = "The total amount received from the provider")
  public Double getAmount() {
    return amount;
  }

  public void setAmount(Double amount) {
    this.amount = amount;
  }

  public Transaction vatExempt(Boolean vatExempt) {
    this.vatExempt = vatExempt;
    return this;
  }

   /**
   * indicates that the item carries no VAT. If not specified defaults to false.
   * @return vatExempt
  **/
  @Schema(example = "false", description = "indicates that the item carries no VAT. If not specified defaults to false.")
  public Boolean isVatExempt() {
    return vatExempt;
  }

  public void setVatExempt(Boolean vatExempt) {
    this.vatExempt = vatExempt;
  }

  public Transaction currency(String currency) {
    this.currency = currency;
    return this;
  }

   /**
   * optional indicator representing the currency of the transaction. Supply a 3 character code as defined by ISO 4217
   * @return currency
  **/
  @Schema(example = "USD", description = "optional indicator representing the currency of the transaction. Supply a 3 character code as defined by ISO 4217")
  public String getCurrency() {
    return currency;
  }

  public void setCurrency(String currency) {
    this.currency = currency;
  }

  public Transaction currencyExchangeRate(Double currencyExchangeRate) {
    this.currencyExchangeRate = currencyExchangeRate;
    return this;
  }

   /**
   * exchange rate for conversion of the transaction currency to the payment currency. The amount fields are multiplied by this rate to determine the amount payable in the payment currency.
   * @return currencyExchangeRate
  **/
  @Schema(example = "0.2123", description = "exchange rate for conversion of the transaction currency to the payment currency. The amount fields are multiplied by this rate to determine the amount payable in the payment currency.")
  public Double getCurrencyExchangeRate() {
    return currencyExchangeRate;
  }

  public void setCurrencyExchangeRate(Double currencyExchangeRate) {
    this.currencyExchangeRate = currencyExchangeRate;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Transaction transaction = (Transaction) o;
    return Objects.equals(this.transactionId, transaction.transactionId) &&
        Objects.equals(this.transactionDate, transaction.transactionDate) &&
        Objects.equals(this.productDetails, transaction.productDetails) &&
        Objects.equals(this.clientDetails, transaction.clientDetails) &&
        Objects.equals(this.intermediaryDetails, transaction.intermediaryDetails) &&
        Objects.equals(this.transactionTypeId, transaction.transactionTypeId) &&
        Objects.equals(this.premium, transaction.premium) &&
        Objects.equals(this.amountExVat, transaction.amountExVat) &&
        Objects.equals(this.vat, transaction.vat) &&
        Objects.equals(this.amount, transaction.amount) &&
        Objects.equals(this.vatExempt, transaction.vatExempt) &&
        Objects.equals(this.currency, transaction.currency) &&
        Objects.equals(this.currencyExchangeRate, transaction.currencyExchangeRate);
  }

  @Override
  public int hashCode() {
    return Objects.hash(transactionId, transactionDate, productDetails, clientDetails, intermediaryDetails, transactionTypeId, premium, amountExVat, vat, amount, vatExempt, currency, currencyExchangeRate);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Transaction {\n");
    
    sb.append("    transactionId: ").append(toIndentedString(transactionId)).append("\n");
    sb.append("    transactionDate: ").append(toIndentedString(transactionDate)).append("\n");
    sb.append("    productDetails: ").append(toIndentedString(productDetails)).append("\n");
    sb.append("    clientDetails: ").append(toIndentedString(clientDetails)).append("\n");
    sb.append("    intermediaryDetails: ").append(toIndentedString(intermediaryDetails)).append("\n");
    sb.append("    transactionTypeId: ").append(toIndentedString(transactionTypeId)).append("\n");
    sb.append("    premium: ").append(toIndentedString(premium)).append("\n");
    sb.append("    amountExVat: ").append(toIndentedString(amountExVat)).append("\n");
    sb.append("    vat: ").append(toIndentedString(vat)).append("\n");
    sb.append("    amount: ").append(toIndentedString(amount)).append("\n");
    sb.append("    vatExempt: ").append(toIndentedString(vatExempt)).append("\n");
    sb.append("    currency: ").append(toIndentedString(currency)).append("\n");
    sb.append("    currencyExchangeRate: ").append(toIndentedString(currencyExchangeRate)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
